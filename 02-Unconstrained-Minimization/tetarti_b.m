% Ορισμός της συνάρτησης f(x, y) και του gradient
f = @(x) x(1)^5 * exp(-x(1)^2 - x(2)^2); % Συνάρτηση f(x, y)
grad_f = @(x) [5*x(1)^4 * exp(-x(1)^2 - x(2)^2) - 2*x(1)^6 * exp(-x(1)^2 - x(2)^2); ...
               -2*x(1)^5 * x(2) * exp(-x(1)^2 - x(2)^2)]; % Παράγωγος
% Υπολογισμός του Hessian
hessian_f = @(x) [20*x(1)^3 * exp(-x(1)^2 - x(2)^2) - 8*x(1)^5 * exp(-x(1)^2 - x(2)^2) + 4*x(1)^7 * exp(-x(1)^2 - x(2)^2), ...
                  -10*x(1)^4 * x(2) * exp(-x(1)^2 - x(2)^2); ...
                  -10*x(1)^4 * x(2) * exp(-x(1)^2 - x(2)^2), ...
                  -2*x(1)^5 * exp(-x(1)^2 - x(2)^2)]; % Δευτέρες παραγώγοι
% Σημεία εκκίνησης
initial_points = [0, 0; -1, 1; 1, -1];
% Χρώματα για κάθε σημείο εκκίνησης
colors = ['r', 'g', 'b']; % Κόκκινο, Πράσινο, Μπλε
% Ανοίγουμε ένα figure για να δούμε την σύγκλιση
figure;
hold on;
% Παράμετροι της μεθόδου
epsilon = 1e-6; % Όριο σύγκλισης
max_iter = 100000; % Μέγιστος αριθμός επαναλήψεων
% Αρχικοποίηση της παραμέτρου λ
lambda = 1e-3; % Αρχική τιμή του λ
% Υλοποίηση της μεθόδου Levenberg-Marquardt με Γραμμική Αναζήτηση
for i = 1:size(initial_points, 1)
    x = initial_points(i, :)';
    f_values = []; % Για να αποθηκεύσουμε τις τιμές της συνάρτησης κατά την πορεία
    local_minima_x = []; % Για να αποθηκεύσουμε τα x των τοπικών ελαχίστων
    local_minima_y = []; % Για να αποθηκεύσουμε τα y των τοπικών ελαχίστων
    local_minima_f = []; % Για να αποθηκεύσουμε τις τιμές της συνάρτησης στα τοπικά ελάχιστα
    
    for k = 1:max_iter
        grad = grad_f(x); % Υπολογισμός του gradient
        hess = hessian_f(x); % Υπολογισμός του Hessian
        d = -(hess + lambda * eye(2)) \ grad; % Κατεύθυνση καθόδου (Levenberg-Marquardt με προσαρμοσμένο λ)
        
        % Γραμμική αναζήτηση για το βήμα gamma
        gamma = fminbnd(@(g) f(x + g * d), 0, 1); % Βρίσκουμε το βήμα με fminbnd
        
        % Ενημερώνουμε την τιμή του x
        x = x + gamma * d;
        
        % Αποθηκεύουμε την τιμή της συνάρτησης για σύγκριση
        f_values = [f_values; f(x)];
        
        % Αν η συνάρτηση συγκλίνει (ελάχιστο), αποθηκεύουμε το σημείο
        if norm(grad) < epsilon
            local_minima_x = [local_minima_x; x(1)];
            local_minima_y = [local_minima_y; x(2)];
            local_minima_f = [local_minima_f; f(x)];
            break; % Σταματάμε αν βρούμε το ελάχιστο
        end
        
        % Προσαρμογή του λ ανάλογα με την πρόοδο
        % Αν η συνάρτηση μειώνεται, μειώνουμε το λ
        if f(x + gamma * d) < f(x)
            lambda = lambda / 10; % Μειώνουμε το λ (βελτίωση)
        else
            lambda = lambda * 10; % Αυξάνουμε το λ (αν όχι, επιβραδύνουμε την πρόοδο)
        end
    end
    
    % Εμφανίζουμε τη σύγκλιση της συνάρτησης με διαφορετικό χρώμα για κάθε σημείο εκκίνησης
    plot(1:length(f_values), f_values, 'Color', colors(i)); % Χρησιμοποιούμε διαφορετικό χρώμα για κάθε επανάληψη
    
    % Εμφανίζουμε τα τοπικά ελάχιστα ως κόκκινα σημεία στο διάγραμμα
    plot(local_minima_x, local_minima_f, 'ro', 'MarkerFaceColor', colors(i)); % Χρώμα για τα τοπικά ελάχιστα
    
    % Εκτύπωση σύγκλισης
    fprintf('Μέθοδος Levenberg-Marquardt με Γραμμική Αναζήτηση: Αρχικό σημείο: (%f, %f), Σύγκλιση σε (%f, %f) σε %d επαναλήψεις.\n', ...
        initial_points(i, 1), initial_points(i, 2), x(1), x(2), k);
end
xlabel('Αριθμός Επαναλήψεων');
ylabel('Τιμή της Συνάρτησης f(x, y)');
title('Σύγκλιση Συνάρτησης με Μέθοδο Levenberg-Marquardt με Γραμμική Αναζήτηση');
legend({'Σύγκλιση Αρχικού Σημείου 1', 'Σύγκλιση Αρχικού Σημείου 2', 'Σύγκλιση Αρχικού Σημείου 3'}, 'Location', 'best');
hold off;